/* eslint-disable */

const errorOverlayMiddleware = require('react-dev-utils/errorOverlayMiddleware');
const evalSourceMapMiddleware = require('react-dev-utils/evalSourceMapMiddleware');
const noopServiceWorkerMiddleware = require('react-dev-utils/noopServiceWorkerMiddleware');
const ignoredFiles = require('react-dev-utils/ignoredFiles');
const fs = require('fs');
const apiMocker = require('webpack-api-mocker');
const mockerApi = require('mocker-api');
const axios = require('axios');
const path = require('path');
const paths = require('./paths');
const protocol = process.env.HTTPS === 'true' ? 'https' : 'http';
const host = process.env.HOST || '0.0.0.0';

module.exports = function (proxy, allowedHost, overwrite) {
    return {
        disableHostCheck:
        !proxy || process.env.DANGEROUSLY_DISABLE_HOST_CHECK === 'true',
        compress: true,
        clientLogLevel: 'none',
        contentBase: paths.appPublic,
        watchContentBase: true,
        hot: true,
        publicPath: '/',
        quiet: true,
        watchOptions: {
            ignored: ignoredFiles(paths.appSrc),
        },
        https: protocol === 'https',
        host,
        overlay: false,
        historyApiFallback: {
            disableDotRule: true,
        },
        public: allowedHost,
        proxy,
        before(app, server) {
            if (fs.existsSync(paths.proxySetup)) {
                // This registers user provided middleware for proxy reasons
                require(paths.proxySetup)(app);
            }

            // TODO 兼容老的 mocker
            if (!overwrite.incompatible) {
                if (!process.env.ori || process.env.ori === 'other') {
                    let mock = path.join(paths.context, 'mocker.js');
                    fs.existsSync(mock) && apiMocker(app, mock, {
                        proxy: {},
                        changeHost: true,
                    });
                }

                app.use('/api/mock', async (req, res) => {
                    const url = req.originalUrl.replace('/api/mock', '');
                    const eid = overwrite.eolinkerId;
                    const base = process.env.REACT_APP_WEB_NAME;
                    /** 这链接不太好用，数据太多会获取不全 */
                    const uri = `https://result.eolinker.com/${eid}?uri=${url}`;
                    const result = await axios({
                        method: req.method,
                        url: uri,
                    });
                    if (!(result.data instanceof Object)) {
                        const urlPre = `/${base}/data`;
                        const result = await axios({
                            method: req.method,
                            url: `http://${req.headers.host}${urlPre}${url}`,
                        }).catch(() => {

                        }) || {};
                        /** 如果有本地mock数据，则调用之 */
                        if (result.status === 200) {
                            res.json(result.data);
                        } else {
                            /** 最后才调用eolinker生成的mock数据（需要自己去编辑格式和方法） */
                            const uri = `https://mockapi.eolinker.com/${eid}/${url}`;
                            const result = await axios({
                                method: req.method,
                                url: uri,
                            });
                            res.json({...result.data, success: true});
                        }
                    } else {
                        res.json(result.data);
                    }
                });
            } else {
                const mock = path.join(paths.context, 'mocker.js');
                if (fs.existsSync(mock)) {
                    mockerApi(app, mock, {changeHost: true});
                }
            }

            // This lets us fetch source contents from webpack for the error overlay
            app.use(evalSourceMapMiddleware(server));
            // This lets us open files from the runtime error overlay.
            app.use(errorOverlayMiddleware());

            // This service worker file is effectively a 'no-op' that will reset any
            // previous service worker registered for the same host:port combination.
            // We do this in development to avoid hitting the production cache if
            // it used the same host and port.
            // https://github.com/facebook/create-react-app/issues/2272#issuecomment-302832432
            app.use(noopServiceWorkerMiddleware());
        },
        ...(overwrite.devServer || {}),
    };
};
