/* eslint-disable */
const fs = require('fs');
const path = require('path');
const webpack = require('webpack');
const resolve = require('resolve');
const glob = require('glob');
const chalk = require('chalk');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const WebpackBar = require('webpackbar');
const CopyWebpackPlugin = require('copy-webpack-plugin');
const CleanWebpackPlugin = require('clean-webpack-plugin');
const CompressionPlugin = require('compression-webpack-plugin');
const CaseSensitivePathsPlugin = require('case-sensitive-paths-webpack-plugin');
const InlineChunkHtmlPlugin = require('react-dev-utils/InlineChunkHtmlPlugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const InterpolateHtmlPlugin = require('react-dev-utils/InterpolateHtmlPlugin');
const WatchMissingNodeModulesPlugin = require('react-dev-utils/WatchMissingNodeModulesPlugin');
const ModuleNotFoundPlugin = require('react-dev-utils/ModuleNotFoundPlugin');
const ForkTsCheckerWebpackPlugin = require('react-dev-utils/ForkTsCheckerWebpackPlugin');
const typescriptFormatter = require('react-dev-utils/typescriptFormatter');
const paths = require('./paths');
const getClientEnvironment = require('./env');

// 是否将运行时代码添加至内联脚本
const shouldInlineRuntimeChunk = process.env.INLINE_RUNTIME_CHUNK !== 'false';

// 是否使用 ts
const useTypeScript = fs.existsSync(paths.appTsConfig);

const DEVELOPMENT = 'development';
const PRODUCTION = 'production';

/**
 * 生成 dll 配置
 * @param overwrite
 * @param wordDir 工作目录
 * @return {{dllPlugins: Array, manifests: Array, dll: Array}}
 */
const generateDllConfig = (overwrite, wordDir) => {
    let dllPlugins = [], manifests = [], dll = [];
    if (overwrite.dll) {
        try {
            // ['react.manifest.json']
            manifests = overwrite.dll === '*' ?
                glob.sync('*.manifest.json', {cwd: paths.appPublic}) :
                Array.isArray(overwrite.dll) ? overwrite.dll.map(i => `${i}.manifest.json`) : [];
            // ['*.manifest.json 磁盘路径']
            manifests = manifests.map(item => path.join(paths.appPublic, item));
            // ['*.dll.js 磁盘路径']
            dll = manifests.map(item => item.replace('.manifest.json', '.dll.js'));
            // 插件配置
            dllPlugins = manifests.map(item => new webpack.DllReferencePlugin({
                context: wordDir, // 与DllPlugin中的那个context保持一致
                /**
                 * 这个字段对应webpack.dll.config.js中生成的那个json文件的路径
                 * webpack打包时，会检测此文件中的映射，不会把存在映射的包打包进 bundle.js
                 */
                manifest: require(item),
            }));
        } catch (e) {
            dllPlugins = [];
            manifests = [];
            dll = [];
            console.log(chalk.red(e.message));
        }
    }
    return {dllPlugins, manifests, dll};
};

module.exports = (webpackEnv, overwrite) => {
    const isEnvDevelopment = webpackEnv === DEVELOPMENT;
    const isNotEnvDevelopment = !isEnvDevelopment;
    const isEnvProduction = webpackEnv === PRODUCTION;

    const publicPath = isEnvDevelopment ? '/' : paths.publicUrl;

    // `publicUrl` 去掉结尾 /
    const publicUrl = publicPath.slice(0, -1);
    // 注入 app 的环境变量
    const env = getClientEnvironment(publicUrl);

    const {dllPlugins, dll} = generateDllConfig(overwrite, paths.appPath);

    // 只有开发时用到的 Plugins
    const developmentPlugin = isEnvDevelopment ? [
        // 热更新 css
        new webpack.HotModuleReplacementPlugin(),

        // 模块路径大小写敏感
        new CaseSensitivePathsPlugin(),

        // 未安装的模块自动安装，不用重启 webpack
        new WatchMissingNodeModulesPlugin(paths.appNodeModules),
    ] : [];

    return [
        // 生成 `index.html` 注入 <script>
        new HtmlWebpackPlugin(
            Object.assign(
                {},
                {
                    inject: true,
                    template: paths.appHtml,
                    publicUrl: paths.publicUrl,
                    timeSpan: new Date() - 0,
                },
                isEnvProduction
                    ? {
                        minify: {
                            removeComments: true,
                            collapseWhitespace: true,
                            removeRedundantAttributes: true,
                            useShortDoctype: true,
                            removeEmptyAttributes: true,
                            removeStyleLinkTypeAttributes: true,
                            keepClosingSlash: true,
                            minifyJS: true,
                            minifyCSS: true,
                            minifyURLs: true,
                        },
                    }
                    : undefined,
            ),
        ),
        //  webpack 运行时脚本内嵌
        isEnvProduction
        && shouldInlineRuntimeChunk
        && new InlineChunkHtmlPlugin(HtmlWebpackPlugin, [/runtime~.+[.]js/]),

        // html 中注入环境变量
        new InterpolateHtmlPlugin(HtmlWebpackPlugin, env.raw),

        // 模块查找失败错误提示
        new ModuleNotFoundPlugin(paths.appPath),

        // js 中注入环境变量
        new webpack.DefinePlugin(env.stringified),

        // 按需清空打包目录文件
        new CleanWebpackPlugin(),

        // 拷贝 public 目录下的文件
        new CopyWebpackPlugin([
            paths.appPublic,
            ...dll,
            // TODO: copyFiles 兼容老项目
            ...(overwrite.copy || overwrite.copyFiles || []),
        ], {ignore: []}),

        // Dll
        ...dllPlugins,

        // 压缩 css
        isNotEnvDevelopment && new MiniCssExtractPlugin({
            filename: 'css/[name].[contenthash:8].css',
            chunkFilename: 'css/[name].[contenthash:8].chunk.css',
        }),

        // 生成资源和相应输出文件之间的映射
        // new ManifestPlugin({
        //     fileName: 'asset-manifest.json',
        //     publicPath,
        // }),
        /**
         * 防止在 import 或 require 调用时，生成以下正则表达式匹配的模块
         * 下面配置意思是 moment.js 里 import ./local 目录下的模块都忽略
         */
        new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/),

        // TypeScript 类型检查
        useTypeScript && new ForkTsCheckerWebpackPlugin({
            typescript: resolve.sync('typescript', {
                basedir: paths.appNodeModules,
            }),
            async: isEnvDevelopment,
            useTypescriptIncrementalApi: true,
            checkSyntacticErrors: true,
            tsconfig: paths.appTsConfig,
            reportFiles: [
                '**',
                '!**/*.json',
                '!**/__tests__/**',
                '!**/?(*.)(spec|test).*',
                '!**/src/setupProxy.*',
                '!**/src/setupTests.*',
            ],
            watch: paths.appSrc,
            silent: true,
            // WebpackDevServe 时触发
            formatter: isNotEnvDevelopment ? typescriptFormatter : undefined,
        }),

        // 打包进度条
        new WebpackBar({minimal: false}),

        // gzip 压缩
        (isNotEnvDevelopment && overwrite.gzip) && new CompressionPlugin({
            test: /\.(js|css|html)(\?.*)?$/i,
            cache: true,
        }),

        // 开发环境插件
        ...developmentPlugin,
    ].filter(Boolean);
};
