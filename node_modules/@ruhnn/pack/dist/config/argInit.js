"use strict";

/* eslint-disable */
var path = require('path');

var fs = require('fs');

var chalk = require('chalk');

var paths = require('./paths');

var getClientEnvironment = require('./env');

var clearConsole = require('react-dev-utils/clearConsole');

var checkRequiredFiles = require('react-dev-utils/checkRequiredFiles');

var mes = "\n\u8BF7\u6307\u5B9A\u6B63\u786E\u7684\u6253\u5305\u76EE\u5F55\uFF0C\u4E00\u4E2A\u6807\u51C6\u7684\u6253\u5305\u76EE\u5F55\u5E94\u81F3\u5C11\u5305\u542B\u4EE5\u4E0B\u6587\u4EF6\n\nprojectDirectory    (\u6253\u5305\u76EE\u5F55)\n    - index.html    (\u6A21\u677F\u6587\u4EF6)\n    - index.js      (\u6253\u5305\u5165\u53E3\u6587\u4EF6)\n";
/**
 * 1. 修改 paths 打包目录相关字段
 * 2. 必要文件检查
 * 3. 合并重写配置对象和命令行参数
 * 打包返回配置参数
 *
 * @param options 命令行参数
 * @returns {{context: *, overwrite: {}}}
 */

module.exports = function (options) {
  var context = options.context,
      buildPath = options.buildPath; // 打包结果目录

  if (buildPath && !buildPath.includes(path.sep)) {
    paths.mergePaths({
      appBuild: path.join(paths.appPath, buildPath)
    });
  } // 指定了 context && context 不是src 目录则修改 paths


  if (context && context !== paths.appSrc) {
    context = fs.realpathSync(context);
    paths.mergePaths({
      context: context,
      appHtml: path.join(context, 'index.html'),
      appIndexJs: path.join(context, 'index.js'),
      overwrite: path.join(context, 'config-overwrite.js'),
      mocker: path.join(context, 'mocker.js')
    });
  } else {
    context = paths.appSrc;
  } // 确保 context 存在


  options.context = context; // 检查文件

  if (!checkRequiredFiles([context, paths.appHtml, paths.appIndexJs])) {
    clearConsole();
    console.log(chalk.red(mes));
    process.exit(1);
    return;
  }

  console.log(chalk.green("\n \u6253\u5305\u73AF\u5883\uFF1A".concat(chalk.yellowBright(process.env.NODE_ENV), "\n \u5F53\u524D\u6253\u5305\u76EE\u5F55\uFF1A").concat(chalk.yellowBright(context)))); // config.overwrite.js

  var overwritePath = paths.overwrite;
  var overwriteFn = fs.existsSync(overwritePath) ? require(overwritePath) : {}; // 重写配置对象

  var overwrite = typeof overwriteFn === 'function' ? overwriteFn(paths, getClientEnvironment().raw, options) : overwriteFn; // PUBLIC_URL 指定优先级
  // 1. 命令行 -r
  // 2. config-overwrite.js..homepage
  // 3. process.env.PUBLIC_URL
  // 4. package.json..homepage

  paths.mergePaths({
    publicUrl: options.root || overwrite.homepage || paths.publicUrl
  }); // 将命令行参数合并到配置对象

  return Object.assign({}, overwrite, options, {
    homepage: paths.publicUrl
  });
};