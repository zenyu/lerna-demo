"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

/* eslint-disable */
var errorOverlayMiddleware = require('react-dev-utils/errorOverlayMiddleware');

var evalSourceMapMiddleware = require('react-dev-utils/evalSourceMapMiddleware');

var noopServiceWorkerMiddleware = require('react-dev-utils/noopServiceWorkerMiddleware');

var ignoredFiles = require('react-dev-utils/ignoredFiles');

var fs = require('fs');

var apiMocker = require('webpack-api-mocker');

var mockerApi = require('mocker-api');

var axios = require('axios');

var path = require('path');

var paths = require('./paths');

var protocol = process.env.HTTPS === 'true' ? 'https' : 'http';
var host = process.env.HOST || '0.0.0.0';

module.exports = function (proxy, allowedHost, overwrite) {
  return (0, _objectSpread2.default)({
    disableHostCheck: !proxy || process.env.DANGEROUSLY_DISABLE_HOST_CHECK === 'true',
    compress: true,
    clientLogLevel: 'none',
    contentBase: paths.appPublic,
    watchContentBase: true,
    hot: true,
    publicPath: '/',
    quiet: true,
    watchOptions: {
      ignored: ignoredFiles(paths.appSrc)
    },
    https: protocol === 'https',
    host: host,
    overlay: false,
    historyApiFallback: {
      disableDotRule: true
    },
    public: allowedHost,
    proxy: proxy,
    before: function before(app, server) {
      if (fs.existsSync(paths.proxySetup)) {
        // This registers user provided middleware for proxy reasons
        require(paths.proxySetup)(app);
      } // TODO 兼容老的 mocker


      if (!overwrite.incompatible) {
        if (!process.env.ori || process.env.ori === 'other') {
          var mock = path.join(paths.context, 'mocker.js');
          fs.existsSync(mock) && apiMocker(app, mock, {
            proxy: {},
            changeHost: true
          });
        }

        app.use('/api/mock',
        /*#__PURE__*/
        function () {
          var _ref = (0, _asyncToGenerator2.default)(
          /*#__PURE__*/
          _regenerator.default.mark(function _callee(req, res) {
            var url, eid, base, uri, result, urlPre, _result, _uri, _result2;

            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    url = req.originalUrl.replace('/api/mock', '');
                    eid = overwrite.eolinkerId;
                    base = process.env.REACT_APP_WEB_NAME;
                    /** 这链接不太好用，数据太多会获取不全 */

                    uri = "https://result.eolinker.com/".concat(eid, "?uri=").concat(url);
                    _context.next = 6;
                    return axios({
                      method: req.method,
                      url: uri
                    });

                  case 6:
                    result = _context.sent;

                    if (result.data instanceof Object) {
                      _context.next = 26;
                      break;
                    }

                    urlPre = "/".concat(base, "/data");
                    _context.next = 11;
                    return axios({
                      method: req.method,
                      url: "http://".concat(req.headers.host).concat(urlPre).concat(url)
                    }).catch(function () {});

                  case 11:
                    _context.t0 = _context.sent;

                    if (_context.t0) {
                      _context.next = 14;
                      break;
                    }

                    _context.t0 = {};

                  case 14:
                    _result = _context.t0;

                    if (!(_result.status === 200)) {
                      _context.next = 19;
                      break;
                    }

                    res.json(_result.data);
                    _context.next = 24;
                    break;

                  case 19:
                    /** 最后才调用eolinker生成的mock数据（需要自己去编辑格式和方法） */
                    _uri = "https://mockapi.eolinker.com/".concat(eid, "/").concat(url);
                    _context.next = 22;
                    return axios({
                      method: req.method,
                      url: _uri
                    });

                  case 22:
                    _result2 = _context.sent;
                    res.json((0, _objectSpread2.default)({}, _result2.data, {
                      success: true
                    }));

                  case 24:
                    _context.next = 27;
                    break;

                  case 26:
                    res.json(result.data);

                  case 27:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          return function (_x, _x2) {
            return _ref.apply(this, arguments);
          };
        }());
      } else {
        var _mock = path.join(paths.context, 'mocker.js');

        if (fs.existsSync(_mock)) {
          mockerApi(app, _mock, {
            changeHost: true
          });
        }
      } // This lets us fetch source contents from webpack for the error overlay


      app.use(evalSourceMapMiddleware(server)); // This lets us open files from the runtime error overlay.

      app.use(errorOverlayMiddleware()); // This service worker file is effectively a 'no-op' that will reset any
      // previous service worker registered for the same host:port combination.
      // We do this in development to avoid hitting the production cache if
      // it used the same host and port.
      // https://github.com/facebook/create-react-app/issues/2272#issuecomment-302832432

      app.use(noopServiceWorkerMiddleware());
    }
  }, overwrite.devServer || {});
};